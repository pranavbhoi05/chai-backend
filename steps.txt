node -v
npm init
 
now initialize repo and add to git
git init
git add .
 git config --global user.email "pranavbhoir182000@gmail.com"    
>> git config --global user.name "pranav"
git commit -m "add initial files for backend"
now go to github and create new repo
after creating gitrepo follow the command which are shown

*git branch -M main  (Renames your current branch to main (GitHub's default branch))
##########################################################################################
* we have not set origin yet so now set remote : git remote add origin https://github.com/pranavbhoi05/chai-backend.git
*now git repo knows where to puch it remotely
################################################################################################
*git push -u origin main  
(Pushes your local main branch to the remote (origin).
-u sets it as the default upstream branch, so next time you can just use git push.)
##############################################################################################

create new file with name .gitignore (we will put some sensitive files here)
* go to gitignore generator in browser and search (node) and create then copy and paste in gitignore file
*create .env file
*we mostly avoid to push .env file in git so hitesh has create .env.sample file so he can share it with us
*now create new folder with name source (all directory files will store in here, depends upon you)
*now create 3 files in src folder (index.js,app.js,constants.js)
###############################################################################################
*now package.json doesnt how we gonna make things work so add(type : "module") right above main : indesx.js
NOTE : why we use module cause we gonna use import syntax (not require syntax) 
WE WILL USE MODEL in this ENTITE PROJECT SO IT WILL MAINTAIN CONSISTANCY IN PROJECT
###################################################################################################
*sometimes we wanted to keep restarting server so we gonna use nodemon
*go to nodemon site
* npm i -D nodemon
note: make changes in package.json file 
     1. make changes in script tag: ("dev": "nodemon src/index.js") nodemon will keep reloading this file whererver we make changes
* check git status then commmit changes
*git  commit -m "setup project files part-1"  
*git push
*we gonna need few folders in src so create folders
mkdir controllers db middlewares models routes utils

###################################################
*prettier must be install to
*npm i -D  prettier and also create file in main brach with name .prettierrc

make changes in that file as per requirment , i did:
{
    "singleQuote": false,
    "bracketSameLine": true,
    "tabWidth": 2,
    "semi": true,
    "trailingComma": "es5"
}

#######################################

create another file with name (.prettierignore) and make changes:
/.vscode
/node_modules
./dist

*.env
.env
.env.*

NOTE:
*The .prettierignore file tells Prettier which files or folders not to format, similar to .gitignore.
*This prevents Prettier from modifying ignored files when running formatting commands.

#############################################################################
STILL:
          WE HAVE DONE DEV DEPENDENCY IN PACKAGE.JSON BUT STILL WE HAVENT INSTALL DEPENDANCY OF  EXPREE AND MONGOOSE


now install MONGOOSE,EXPREE,dotenv

*install dotenv cause all the things we will load from environment variable 
* whenever we talk with database it always take time, in that case we are going to use async await(try,catch) or promices
*never connect databasea in singel line always use async await
now go to index,js
*use effie and async operation
*make sure the import thing
*store mongose in variable

#####################################################

2nd approch:

*create js file in db folder
*import mongoose and db name
*then add (trycatch) async and await both in seperate variabela and give console.log(`\n Mongo conneced !! DB host:${connectionInstance.connection.host}`) by adding connection .host i ll get to know which database im connecting (cause there are indivisul db's for production,testing,development)
* in catch make sure to add precess.exit(1)  to handdle error
#NOTE : process.exit(1) = *"This error is so bad, we need to stop everything now." üî¥
                   *Use it only when continuing would cause worse problems than shutting down. 
*then export it
*export default variablename   


now import that variable index.js file and callback
but
in src index.js always import.env file in code at very first line
 *we also need to config that file :
  dotenv.config({
  path : `./env`
})

now go to package.json and edit
"dev": "nodemon -r dotenv/config src/index.js"
also
Without this flag, you'd need to:
Add require('dotenv').config() at the top of index.js
NOTE : What -r dotenv/config Does
Preloads the dotenv package
The -r flag stands for "require" and loads the specified module (dotenv/config) before your application starts.

Automatically loads .env file
The dotenv/config module (from the popular dotenv package) automatically:

*Looks for a .env file in your project root
*Parses its contents (key-value pairs)
*Injects them into process.env

####################################################

then run numrun dev

$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
3/4/2025 vid no 9 = api responce and error handling

*previously our db was succesfuly connected but our app was'nt connected
*our new task is to start listen from app

*go to app.js and import express
*as we have (connected db ) in (db folders index.js) we have to return promises in main index file too, why ? (cause we have written async method in db folder and whenever we write asyck method, then techniquly we have to return promises (main)in index.js file too)

*now at .then() and .catch() method and add listen method 
*also add app.on You can listen for errors (though Express has its own error-handling middleware).

#####################################################################
*go to express documentaion for more info
*req.params : whenever we receive data from URL mostly come from (req.params)
*req.body : data comes in forms and json format in (req.body)
*sometimes we will take data cookie 
#######################################################################

*go to browser then search for npmjs and search for cookie-parser and corest to see documentaion 

now install cookie-parser and cors:

*npm i cookie-parser cors
NOTE : you can check in package.json is they are install
*now  import this files in app.js
*now configure this files in here:
app.use(cors())
NOTE : this (use) method use in middleware and configuration
we can also do setting like : we can define origin (urls)

*make changes in that cors method : 
*1.add origin in {} and give path to link (add from env file) but first need to create that variable in process.env.CORS_ORIGIN file
NOTE :  whenever we SEE (*) in origin it is known for allow all request 
#NOTE:  CORS CAONTAINS OBJECT

*now (,) and ctrl + shift (to see more option)
* credentials : true

###################################################

NOTE : more settings to do before we jump to cookies cause data is gonna come from many places like :
1. url,
2.json format,
3.few will send in body (form),
4.few will send form in json

SOMTIMES WE NEED TO ADD SOME LIMITS IN IT CAUSE WE DONT WANT CRASH OUR SERVER CAUSE OF (UNLIMITED JSON FILE AND ETC)
*now again add app.use(express.json()) in app.js
[this line mean we are accepting json format in express]
*again ctrl + shift (to see more options)
*set LIMITS (i did 20 kbs)

*somtimes data comes in the form of url in the format of (e.g %20)
to make that urls understandable we add (express.urlencoded) in app.js
*can also add extended (its like can give nested object) its not nessesry to give and we can also add limit

*somtimes we wanted to store files,pdf or images , then we create public folder which amyone can anyone access
app.use(express.static("public"))

NOTE : this 3 majer components are imp in app
express.urlencoded
express.json
express.static
*also add cookieParser() in app
cookie-parse = to access and set cookies in user's browser, by using this (only server can read and perform operation on it)

########################################################################################
4/4/2025 vid no 9 (api responce and error)

#read notes about middlewares cause we gonna use it now
#Middleware can block requests like an (if condition), but it‚Äôs more powerful. (e.g instagram url login)
#we can add multiple midleware for checking
#note : (err,req,res,next) after fulfilling the condition (next) flag will move to another condition to cheak

#######################################################
#utils

#just cause it takes time in dbconnect so its esetial to use async await
#and try catch is also required to apply 
#we got 2 option either we can use (trycatch) or (.then.catch)

 

* we have set higher order function in variable (asyncHandler)
*const asyncHandler = (fn) => async (req, res, next) => {
*now apply trycatch
*in catch use res.status method 
error.code and you also send 500
*can also send add .json responce
*we add success flag in .json (so the frontend person will get easy)
*also add message in .json flag
* (try) part : 
await fn(req, res, next)

###################################################
2nd approch using .then and .catch

*const asyncHandler = (requestHandler) => {
    return (req, res, next) => {
        Promise.resolve(requestHandler(req,res,next)).
        catch((err) => next (err))
    }    
 }
 *export { asyncHandler}

 ###################################################

 5/4/2025 (creating structure of errors)

#we have to makes errors in centralizze from (so we will not have to revise this all the time   )
#we wanted to statderdize error of api and responce of api
#so we gonna have to write code,it willbe benefitial. (benefits): all the responce and error will come in standerdize form
#browse site : nodejs api error
#as we do know js, we have knowladge of classes and inheritance (so we can overwrite the error methods) 

*create file (apierror.js) in utils
*create class named(apierror) and extend with Error
#read documentaion in error.txt (i have mention (error.txt) name file in this folder)

##########################################################
5/4/2025 (apiresponce.js)  same video

CODE: class ApiResponse {
    constructor(statusCode ,data, message = "success"){
        this.statusCode = statusCode
        this.data = data
        this.message = message
        this.success = statusCode < 400
    }
}

*create new apiresponce.js file in utils
*we send statusCode in this.success 
*we always have to provide server status code in sucess 
*just because we are sending responce so we will take statuscode below (400)
*but in error you can send more than (400) 

NOTE: SEE DOCUMENTATION OF STATUSCODE

$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

6/4/2025  2:32AM  (video no 9 user and video model wuth hooks and jwt)

# FEW SETTING ARE YET TO SET  : whenever error appears it must go through apierror.js

#waste day (just watch video and did not implement)

$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

7/4/2025  12:47am (video no 9 user and video model wuth hooks and jwt)

NOTE: in this topic we will see: 
1.how to write aggrigation pipeline 
2.jwt 
3.bcrypt
4.how models are created in mongoose 

###########################################

*create file (user.model.js) and (video.model.js) in models folder
*go to readme file where i saved eraser file
*now create schema for user model and video model
#after writing models on user and video(we have to work on watch history , it makes our project complex and next level)
#for that we goona use package ,(mongoose-aggregate-paginate-v3) from npm (READ AGGREGATION PIPLINE) aggrigation means collection.
#true power of mongo db comes from aggregate queries 

*install : npm install mongoose-aggregate-paginate-v2
*inject in video.model.js (import mongooseAggregatePaginate from 
"mongoose-aggregate-paginate-v2";)
#NOTE : before export you gonna have to use it,ALSO read plugin,middleware in npm,you can create your own plugin too

#bcrypt : (A library to help you hash passwords.)
#jwt (json web token): 1. to create token , 
                       2. for cryptography (to handle encryption,decryption)
*npm i bcrypt 
*npm i jsonwebtoken
*import jwt and bcrypt in "user"
#direct encryption isnt possible SO we'll take help of(hooks),go to documentaion of mongoose and click on middleware, you'll see hooks
#pre (hook) : whenever user make changes in data (controller), just before saving it we can run operation like(pass encryption)

#which event u want use in pre
1. validate
2.save
3.updateOne
4.deleteOne

*go to user
*userSchema.pre("save", async function(next){
    if(!this.isModified("password")) return next()
    this.password = bcrypt.hash(this.password,10)
next()
} )
#now our pass is encrypted and saved
#CHECK OUT USER.MODEL.TXT FILE (FOR UNDERSTANDING)

################################################
*NOW WE'LL CREATE METHOD (WHY) : to verify the password is valid or not , 
# WE CAN Also DESIGN COSTOM METHOD
*go to user.model.txt for NEXT CODE 

#################################################
JWT (json web token) : (its like key )anyone who got this token, i will share my data
#go to site jwt.io site (for more info)
#What is a JWT Bearer Token?
1.A compact, URL-safe token following the RFC 7519 standard
2.Contains JSON payload with user claims (e.g., user ID, roles)
3.Used as a Bearer token in the Authorization header

*now we will generate access token
*go to env file
*To generate ACCESS_TOKEN_SECRET Go to site : sha 256
*ACCESS_TOKEN_SECRET
*ACCESS_TOKEN_EXPIRY
*REFRESH_TOKEN_SECRET
*REFRESH_TOKEN_EXPIRY
#we are using session and cookies at same time
#access token isnt going to store in db, while refresh token will be saved in db

#########################################################################
# access token generate method: 
                                to generate access token its same process as we create our own method (above)
 
* in user.model file : (read jwt sign syntax):
*jwt.sign({
  data: 'foobar'
}, (path of ACCESS_TOKEN_SECRET), (path for expiry token) in {expririn : }
*use this syntax to create model for creating(access token and refresh token) 
)

NOTE : OUR SCHEMA STRUCTURE HAS BEEN created

$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

#9/4/2025 10:4 pm (video no 10 : How to upload file in backend | Multer)
# NEXT TARGET : HOW TO ADD DATA IN DB (WHICH WE HAVE CREATED )
#we dont do file handling in our own server,either they use their specialize 3rd party services or aws 
#we gonna use clodinary(will file upload on its server) and multer(will upload file through multer)

(what we gonna do):
                1.we'll take file from user, and will keep that file on our own server for temporary
                2.next we'll take that file from local storage (our server) and upload on cloudinary 
		3.next by using fs we'll write code to unlink(delete) the file which is we kept on our own server

*npm i cloudinary
*npm i multer
*created file name cloudinary.js in utils
*now import clodinary in that file
*also import fs 
*copy entire code from clodinary side and paste in file 
*all configuration are given by clodinary ,we jsut need to make few changes
*we gonna have add few things in .env file which are: CLOUDINARY_CLOUD_NAME =,CLOUDINARY_API_KEY = ,CLOUDINARY_API_SECRET = 
#NOTE : we can make changes in our cloudinary api keys,name and secret

#Upload the image to Cloudinary 
*we'll create method and give path of local file , once file successfuly upload ,we will unlink that file 
*files are complex are same as db, so we'll apply trycatch in here 
*we'll add condition if local path is present ot not (if not present we;ll return null)
*next step upload the file on cloudinary , we can also add resource_type(e.g png,img,video)
*just because its async task we'll add await and hold in variable , also print the responce (console.log('File uploaded to Cloudinary:', response.url);)
*make sure to return responce to user

#if file is not successfuly upload , so we still have option of catch
#upload is not successfull then for safty perpose we need to unlink(delete)the file,else currupted file satys in server
*now write fs method in catch(), will use unlinkSync (sync) insted async cause we want to perform that process immidiatly
 *return null and export cloudinary 

#############################################################3
creating middleware unsing multer:
*go to multer documentaion and copy the syntax 
*just cause in that syntax (req, file, cb) file is coming ,thats why we using multer
#cb (callback)
*i'll make all changes in public file,so made changes in it :  cb(null, './public/temp')

*filename : if u want to change filename like unique file name
#file.originalname ‚Üí The original name of the uploaded file (e.g., image.jpg).


#cb(null, file.originalname):
# 1. Keeps the original filename (no modification).
# 2. Risk: If two files with the same name are uploaded, the second will overwrite the first.


#Use Case of Date.now() in Multer Filenames
When handling file uploads, Date.now() is commonly used to generate a unique filename and avoid conflicts. Here‚Äôs why and how it works:

* export const upload = multer({ storage: storage })

#now just cause i have multer, when i write routes and controlers, when im expecting files will come from that route,then i'll go to that route,and write storage method and call it 
#NOW WE CAN HANDLE ANYKIND OF FILE handling ,like vids,img,pdf etc 

$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

#15/4/2025 (video no 11 : http crash course)
#read notes that o have created 

$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

#15/4/2025 04:47 pm (video no 12 : router and controller with debugging)

#CONTROLLER : Handle HTTP requests/responses (validate inputs, process data, return results).

*create new file in controller (user.controller.js)
#we have created helper file before ,incase if we face problem ,we've created wraper file(asyncHandler)
#the only benefit is we won't need to put each things into (promises)trycatch everytime
*so import  asyncHandler file in user.controller.js file
*now we will create method and that methos's only task is to register a user
*as previously we created asyncHandler which is higher order function which accept function, we'll write aync method in that function (req,res)
*now give responce in status(e.g 200) and also give json responce as u like
*now export registeruser

########################################################################
NEXT STEP : CREATE ROUTES
(as we have created the method,but atleast that method suppose to run on url, so that we create route)

*create fiel user.route.js in rouder folder and in that file
*import {router} from 'express';
const router = router();
export default router;

#we can also import this methods in index.js but it must be clean
*so we will import this all things in app.js (cause production grade standerd)

#we always write routes after cookieparser in app.js
*import userRoutes from "./routes/user.routes.js"
#NOTE userroutes is just variable give name as u like (e.g import myCustomUserRoutes from './routes/user.routes.js';)

#priviosly we use to write route and controller at same time through (app.js)
#but just cause we made all the things separate,we have write router separatly, so to bring router we need to bring middleware here 
#so insted of app.get we'll use app.use

*after importing routes to declare routes: 
app.use("/api/users", userRoutes)
# understanding the statment : always write /api for staderd terms,
# users is like variable give any name u like,
#userRoutes for which router u want to activate (which we already created)


#as we have write this middleware,now anyone who type /user , then this mean u r giving control to userrouter
then userrouter will take u to user.routes.js (which is location) and it will ask, on which route u want send user
#then we will write route method in user.routes.js  

*router.route("/register).post(registeruser)
#explanation : we have newly created (/register) method here , and we've added post method, in this post method we've added method which has to be run , so we give  (registeruser), which we previously created in user.controller.js
once user hit (http://localhost:8000/api/users/register) , it will take him registeruser
*also import registeruser in route file

#if we wanted to create login method, we won't need write import statement
*if u wanted to create login method simply go to routes and create methos as we created register method
#we will not make any changes in app.js
#all the methods we gonna write after user will be written in user.routes.js
#"/api/v1/users" = v1 for currenet version (standard practise)

*makke sure to return asyncHandler in asyncHandler file 
*npm run dev
*if success server start then , go to postman site and paste your http url on + symbol url option
*make sure to choose post option in it 

#as we have got result from postman : status 200 and json response "ok, cause we have asked to give this two inties in controllers

$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

#17/4/2025 12:20 pm (vid no 13 LOGIC BUILDING | REDISTER CONTROLLER)

(in this topic we gonna properly regiser user,we will take data from user
 through postman e.g name,email,photo etc , we will take this data to 
 server and we'll add this to database, if face issue we'll also debuge)


(algoritham) : steps to solve this probs 

#just cause we dont have frontend ,we gonna take data through postman(get req,post req), and it also depends upon how we create models(username,fullname,email,password,)
#validation : incase if user send empty username or email , email is in correct format or not and all the posible validation
#check if user already exists : if his accout already exist (check yhrough username or email)
#check for image , cheak for avatar : check our file exists or not
#upload them to cloudinary after we'll check avatar is uploaded or not
#create user object  :(why) cause when i send data in mongodb, and its no sequel db we mostly create object and upload it,so right after creating object we'll do creation which is - (create entry in db)
#remove password and refresh token feild from response : we dont wanna share pass and refresh token to user
#check for user creation success or failure
#return response to frontend if successed 
 
#############################################################################

#its not nessesry if data come from body , it can come from url

#step  1 : 
       *in user.controller exreact data using destruturing of object which we want (fullname,email,username,password)
       *for testing  console log (email),go to postman,past url,select body cause we r taking data from body,then select raw and then json
       *enter data for testing in object format

#file handling : we cant handle file here, but we can handle data only 
                #as we have created multer(middleware) for file handling, look for exported filename
                * go to routes and import upload file
                #as we know middleware means (jate samay muzse milke jana),so we'll add middelware before execution, so 
                *add upload just before execution (post(upload.feild[]),registerUser), just by usning dot we get to see various methos
                #we choose feild cause it accepts array and we can now store many feild in that array as mush as we want,but in objects format
                #to userstand more i have created txt file named avatar
                #we took two feild avatar and cover image, can also take many 

#step 2: check validation   
    *we'll add id condition if value exist or not , we've create api error file so we'll also use that file to send status code and passing messages    
    *make sure to import apierror file
    #to check multiple errors at once we'll pass array and will use .some method (speciality : returns result in true or false) , we can also use .map
    #insted of checking single condition we did add arry so we can check multiple feilds, so we can apply some or map method
    #i have created txt file name (optional chaning) to understand ? and trim() 

#step 3: user exist or not 
    *import user from model (this user can directly contact with db, cause its made by mongoose)
    #now this user will call on behalf of us
    *we use findone method(if user is successfuly find , then returns)
    *we'll ask to db to find the user which contains (e.g email or username) , if provided data matches,then throw error
    #we'll use operator $or (to check if either username or email is already exist ot not)

#step 4:  check images and avatar is uploaded
        #till now, we get all data in  req.body,but just cause we have created middleware in routs, so middelware also gives access few things, what middleware do(add more feilds in req)
        #as express has give (.body) by default, multer gives us (.files) access
        #why we use req : req Contains the Uploaded Files
        When you upload files using middleware like Multer or express-fileupload, the files are attached to the req (request) object under req.files.
        #Without req, we wouldn't have access to the uploaded files.
        #i have created file of chaining.txt (read it)
        #incase if we have access of that files or not so  used optional chaining,then i add avatar, cause i want avatar(go to routes file where i declare)
        #with avatar we get multiple options like png , jpg, size
        #NOTE : 1.If the form field is named avatar (without array notation), req.files.avatar will be a single file object (not an array), so you can access its path directly
                2. If the form field is named avatar[] (with square brackets, allowing multiple files),
        # in this code req.files?.avatar[0]?.path : we took [0] cause we want its first property, we took optionally
        # for path as have declear path in multer file 
        *store in variable (avatarLocalPath), why local path ? , cause file is in our server, but not on cloudinary 
        *same process goes to coverimage
        *atleast avatar image is required , so add if condition , check if image exist ot not

#step 5: upload them to cloudinary
        #as per our avdanced preparation,we knew, we'll upload on cloudinary or (aws), so we've already write the code of cloudinary
        *import UploadonCloudinary in user controller
        #if u observe , u have write the code for failure(will delete file), but in success,we have'nt write the code for delete the code 
        *to upload file : UploadonCloudinary(avatarLocalPath) , this process take time so add await and store in variable
        *again add if condition , to check avatar exist, incase if file not exist, code will crash

#step 6: create user object and
#step 7: remove password and refresh token feild from response

       #to make entry in db we had priviosly created user which talks with database
       *user.create({}) : this method take objecrt
       *we take fullname and avatar's url , why only url? (cause we dont wanna send entire object,we'll send only url to db)
       *will also add coverimage : coverimage.url , but the prob is we'havent add consition to check if coverimage exist or not so we add ?. optional chaining
       #and just cause its not exist, in that case add || (or) in "" empty string, cause its not compulsary   
       *take email,password and username : username.tolowercase() 
       *hold in variable and await , cause takes time while talking with server in server in diffrent continetal
       #make suer to await in usermodel, in bcrypt , cause password hashing takes time           
       #to check if user is created or not we got better approch : .findbyId(where we can pass id )
       #when user is successfuly create, it doesnt just create data(e.g username,email,avatar) but also mongodb add _id feild with each new entry
       #why use .findbyid() : 
       #Fetch data from database: 1. it's a quick and direct way to get a document by its _id.
                                 2. Example: You received only a user ID (e.g., from a token or request) and need full user info from MongoDB.
      #if user is found then user was created , if not then we''ll throw error
      #hold in variable and await
      *just by using findbyId method, if we find user then we can optionally chain by using select method, this method will help you to remove refresh token and password
      *select("-password -refreshToken")

#step 8 : check for user creation success or failure      
      
      *also throw error for failure , 500 cause its ours falut

#step 9 : return response to frontend if successed
        
        *make sure to export apiresponce in apiresponce file
        *import apiresponce in controller file
        *return res.status(201).json() : will send current status code and json responce, we'll send it in object format
        * in json () create new object of apiresponce 
        * in that newly created object add statusCode, createduser(which is data), and message of successfuly created

$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

   REMAINDER :  5 MAY 2025    2.11AM
I MADE A MISTACK WHICH TOOK ME 1 WEEK TO RESOLVE 

*review why we use
 1. import path from path and 
 2. const normalizedPath = path.resolve(localFilePath);

check file (big problem) for solution

 $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

#05/5/2025 2:20 pm (vid no 14 How to use postman for backend)

#go to postman site or download and select post and paste url and add the credentials in form.data
#also check in mondodb and uploaded files in cloudinary 
#everytime user created (_id) generates automatically
#also clodinary automatically create public url for uploaded files
#unlink file in clodinary just before return , cause our testing is done , now we want our file remove from db ,even if it fails to upload
*  fs.unlinkSync(localFilePath)
# try to console.log(req.files)

#we have added check for avatar if avatarLocalPath is exist
#NOTE : # there is no gauranty if coverimage is created , what if its undefined(""), and if its undefined then how to optionally get url from coverimage
#we'll use classic if condition : 1. req.files : to check files are exist 
                                  2. create array and use isarray() it check if its array or not
                                  3. if its array then its lenght is more than 0 or not
                                  4. now we can set local path : store in variable :  req.files.coverImage[0].path   
                                  # same thing we can do with avatar
#make changes and config in postman

$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
# 09/5/2025 1:20 pm (Access Refresh Token, Middleware and cookies in Backend)

#byusing acces token and refreshToken we'll create login method
*in controllers create login user and write to list

#NOTE :

*step 4 : check for password :
                                #NOTE : DON'T MAKE CHANGES IN CAPITAL (User : belongs to mongoose) , insted use this (user)
                                *await cause take time and use small(user)
                                *we gonna use isPasswordCorrect(which is created in  user model) in user controller , now we can directly access this.password property along with entite isPasswordCorrect function 

# const ispasswordvalid = await user.isPasswordCorrect(password) : in this statement we using Password from req.body 
*add validation for password
#step 5 : its too common to use access and refreshToken , so we'll create separate method for it,so whenever we wnated to access tokens we'll call that method
#make sure to create that method on top of the controller file 
*i created generateAccessAndRefreshTokens , i wont use asynchandler here cause we'arent handling web request here, cause its our intenal method
#we gonna have to pass userid,also gonna use trycatch for error handling
* so in this method (generateAccessAndRefreshTokens) i'll add async and create function with parameter userid, in that function use trycatch
*to generate token , we need to find user, so create method to find user (userid) 
*create method for access token and refresh token and hold in variable : 
    e.g  1. const accessToken = await user.generateAccessToken()
         2. const refreshToken = await user.generateRefreshToken()
#tokens are generated but they arent gone out of method
*we give access token to user but we keep refreshToken in db , so that we dont need to ask password frequently
#so how to add refreshToken in db, and how to add value in object :
*user.refreshToken = refreshToken
#understanding the code : user is an object representing a user (perhaps pulled from a database or created during login).
                          refreshToken is a variable (most likely a string) that holds a new refresh token (used to keep a user logged in after their access token expires).
                          You're storing that refresh token on the user object, probably to save it later or send it somewhere.

#also gonna need to save user, when we gonna save mogoose model will kick in in user model (passwordfeild), whenever we save, password is nessesry
#in that case we use validatebeforesave method : 1.  It's an option you can use when saving a Mongoose document to enable or disable validation before saving it to the database
                                                 2.  This tells Mongoose not to run validation checks (like checking required fields, string length, etc.) before saving the document.
                                                 3.  Using { validateBeforeSave: false } skips that validation, which can be useful in specific cases:
                                                    *You‚Äôve already validated the data manually and don‚Äôt want Mongoose to do it again.
                                                    *You‚Äôre making a partial update and know it will pass later validations.
                                                    *You want to avoid validation errors temporarily (e.g., during data migration or patch operations).
*user.save({validateBeforeSave: false}) and make sure to await , will take time
#now we have our refreshToken and accessToken, we have also store refreshToken in db,but we've refrence of refrencetoken in here, so when the method succesfuly till now, then return both refresh and access token
* return {accessToken, refreshToken}
#we have successfullyreturn it but in method not in login system
#now whenever we needed access and refresh token i will call generateAccessAndRefreshTokens method, which we have created 

*in step 5 add : generateAccessAndRefreshTokens and pass (user._id) also await and add destruturing of access and refreshToken 
#when we await generateRefreshToken this method it returns accessToken & refrencetoken 
#const {accessToken , refreshToken} = await
   generateAccessAndRefreshTokens(user._id) : This line is using destructuring assignment to extract accessToken and refreshToken from the result of an async function called generateAccessAndRefreshTokens.
#The variables are:
1. accessToken
2. refreshToken
These two variables are being declared using const and assigned values from the object returned by the generateAccessAndRefreshTokens function.

 we'll add few changes : 
#we should never share password to user
#right now user we've create his refresh tokens are empty
#u can either update the user object or add user query
#we are doing login method, so it's (user) will have its own (user)method, (its same as we previouly created method for register user method)   so  we need to hind refresh token and password. so we'll add another db method  
*const loggedInUser = User.findById(user._id).select(
    "-password -refreshToken"
  )

 6. set cookies :
  #whenever we send cookie we need DESIGN few options of cookie ,
  *our cookie can be modify by default , but when we add httpsOnly:true and secure:true, this cookies can only be modify by server, frontend cannot modify
  *now return status code and also send tokens and (http)options, you can send cookies as much as you want by using .cookie().cookie 
  *in .json send apiresponce 

 #but still we havent set route for this method 

  #also we can also perform logout method too here, its easy
  #to perform logout method we have 2 task to do :
  task : clear user cookies and remove access,redresh tokes from usermodel 

  *create logout method using asyncHandler 
  #we need to create middleware first 
  if i give form to someone and ask to logout , he will log out anyone one he wants by adding his emailid, for this solution we need to learn one concept
  #as we know we study middleware,(meet me before go), we'll use this concept, we also learn multer which we use to send images with form data, this is what middleware is
  #now if u clearly see req and res this all are just an object , in that object we add cookies,we add files through multer ,and by using cookieParser we add cookies
  #thats how we can use our own too , we can design our own middleware (thats we are gonna do)

  #as you can see in app.js just by using app.js we add cookieparser ,  by doing this now we can access cookies in controllers,
  #cookies access 2 ways,(you can access cookies in responce, cause we added new object),you can access cookies in request (.cookie) why? ,causw we add cookie as middleware

 #lets add our middleware
 *create new file name auth.js in middleware (this middleware will verify if user is exist or not)
 *directly export with const  variable (verifyJWT)
 #when WE login in the user, then we provide him access, refreah token , on its bases we'll verify if user got right tokens or not, if you got true login then
 we'll add(create) new object in req e.g (req.user) , give any name req.pranav

#NOTE : next = my work is done, now forward this where you want

#how to get tokens access , req has access of cookies, in app.js we have given accessfor cookies (cookieParser), so now we have access of cookies 

*req.cookies.accessToken ,why accessToken (cause we have added in contollers and have access of this token)
#we'll see refreshToken in next video,and how it will be use in frontend
*add optional chaining (what if cookies doesnt have access of accessToken)
# what if user is sending custom header req.header(),whenever header comes it commonly use for "Authorization"
*also add optional chaining after Authorization
#you can find this option in postman go in header < we write name Authorization and in send value in format of (Bearer _ tokensname), syntax (Authorization : bearer <token>)
#we does'nt want the whole bearer token, we just wants tokens value
*so we use javascript here with (replace) method and we replace (Bearer and space) with (""),now we'll only get tokens value
#now we'll get token from cookies or we'll get from Authorization
*hold this whole thing in variable name(token)
* if(condition) if token doesnt exist then throw error
*if token exist then we'll ask to jwt (token is right or wrong,and what info is in it)
*import jwt and import apierror
#then ask jwt to verify(we directly get verify method in jwt here)
#there are 2 things need to provide to verify the token : (token:string) and (secretOrpublic key path)
#we can generate tokens and can also add info but only 1 specific person can decode who got (secret key)
#hold this whole thing in variable (decodedToken)

#NOTE : (decodedToken) In short:
1.The line jwt.verify(...) both verifies the token and decodes it.
2.The decoded token contains the payload data (like user ID).
3.That data is used to find the user and attach it to the request.

#now we gonna await cause we'll perform operation of database _id
*import User form model
* await User.findById(decodedToken?._id).select("-password -refreshToken")
# Why this task is necessary
üîê 1. To ensure the user still exists
    2. To get the latest user data
 # we took _id refrence from user model
 *hold in variable(user) and add condition if user exist

 #if user really does exist then,as we have access of req here we'll add new object here
 * req.user = user
    next()
   #req.user = in here user is variable
   #user =  im giving access of user to req object(user)
   #just cause our work is done so next() 

#we'have created middleware and also exported it ,  but how middleware are getting use,middlewares are mostly use in routes
#all this work we should have do in (trycatch)

#as we know we created login method but did'nt create route , lets create route
*go user.route and create new route for loginuser : we'll take post cause we are taking informationx
*create new route for logoutuser
*make sure to export logout user in user.controller
*now whererver i wanted enject the middelware, before this method runs:
router.route("/logout").post(logoutUser), then just before logoutUser i'll add (verifyJWT) method here, and thats it,middleware enject
# whenever we write this 2 methods, then router confuse which method runs first, but who will tell the route which should be run first ,so
#so thats why we wrote next() in the end in auth.js file
# when (verifyJWT)'s  works done then it will move to next (logoutUser) by help of next()

#summery : 1. we ask to verifyJWT, then verifyJWT comes from auth middleware
           2. it will take token from cookies or from Authorization 
           3. then verifies the token and also decodes the token   
           4. if user property found then , add user info in req.user(which is variable), and then next

#now just cause you have reached to logout method (in routes), and just before one middleware is already exicuted
# in user controlers, when i go to logoutUser method ,priviosly i had only access of req.body 
#but now i have access of req.user

#currenetly :
#i was login and i had access token, and on that bases i run query in db and add one req.user,
# NOW I HAVE ACCESS OF REQ.BODY,REQ.COOKIES AND REQ.USER
* if req.user is available then get _id from it and  

#priviosly we were not able to access _id but now we can access
#findByIdAndUpdate : dont ask many things like findbyid,it ask two things :
1. it ask query (user_id) and what needs to be updated 
#User.findByIdAndUpdate(req.user._id, { $set : undefined })
#in this method(findByIdAndUpdate) we use mongodb operator , and its name is (set), set basicaly asked which feild needs to be update
#we also and (new : true)  , explanation: in return it will give new updated value  
*await the User (no need to store in variabe)
#now refreshToken are removed from db , its time to clear cookies from db
*add cookies (so only server can madify cookies) , simply copy from userlogin(controller file)
#NOTE  : make sure to write same name (accessToken) in clearcookie as we write in userlogin method and send options too 
#NOTE : sometimes we write (req,_,next) insted (req,res,next), cause sometimes res is empty so we use (_)

#we could have write our middleware in controlers too, but we write it in separatly in middleware so code can be reuseable for e.g add post or like the post

$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

# 19/5/2025 6:00 pm (Access token and Refresh Token in Backend)
#we'll create endpoint in this video (for tokens)

#24/5/2025 had issues with loginUser :  i didnt match password with registeruser that cause username and mail issue happned
#also add logout route in postman and (save as), we send the all collection to frontend so we create collection of register,login ,logout etc

27/5/2025 5.00pm
#as we know we were gonna talk about tokens in frontend (auth middelware)
#things needs to know about tokens:
                                    we use access and refresh token so user wont need to enter userid and pass everytime
                                    when frontend send request to get token (to refresh access token) so that we need to give endpoint where it will hit the api(that refresh my access and refreah token)

# so we'll create endpoint for user                                    
*in user controllers we'll create controller method (refreshaccesstoken) before creating endpoint.

*step 1: whererver we want to send refresh token,then we can access from cookies ,if anyone hitting that endpoint then we can access from cookies
but what if someone using mobile app then we'll send from req.body, also hold in variabe (incomingrefeshtoken), i give this name cause i do also have refresh token in db

*step 2:  add if condition if incomingrefeshtoken doesnt exist 

*step 3:verify incomingrefeshtoken, before that import jwt in usercontroller
#we did same thing before in auth middleware, we verifyJWT tokens in here, we get decoded info
#while verifing token we give two things : token and REFRESH_TOKEN_SECRET 
#hold in variabe (decode token), so we get decoded info 
#just cause i have access of _id in refresh token (in usermodel),and if i have access of it so now i can run query in mongo db and get info of user  
#use USER.findById to find user and hold in variablename (user),and add if condition if someone send wrong token 

#we got token in two ways : 1. incomingrefeshtoken  (decodedToken) and
                            2. when entire refreshtoken was created in (model), then we also save that token in generateAccessAndRefreshTokens (user.refreshToken), this encoded (refreshToken) token we also saved in user ,
so we gonna have to match this tokens
*so we will compare this incomingrefeshtoken(just cause its encoded,we did choose decodedToken to compare) and user.refreshToken in if condition

#to to send cookies in token create (options )method , you can write this options before or after (gererating token)

*step 4 : generate new token
#now generateAccessAndRefreshTokens(user._id) and return responce, also send cookie in responce
#while sending responce , in cookie, we havent store access and refresh token so 
#we'll decode that token in generateAccessAndRefreshTokens : (const {accessToken , newrefreshToken} = await 
  generateAccessAndRefreshTokens(user._id))
#also send json responce, WHILE sending json responce their can issue while sending refreshtoken , cause we have already use refreshToken name in user
# so change the name of refreshToken while destructuring access and refresh token
#also send message

#add trycatch from decodedToken to all (for error handling )
###now we have our controller but still dont have endpoint, to create endpoint go to route

*whiel creating route make sure to export refreshAccessToken in controller and import in route
#and just cause i have write all the jwt code in controller so dont need add verifyJWT middleware in route
**save